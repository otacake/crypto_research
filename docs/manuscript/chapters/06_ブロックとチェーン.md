# 第6章: ブロックとチェーン

第5章では、UTXOにより競合取引を同じ粒度で判定できる土台を作りました。本章の問いは、その判定結果をどのように記録すれば、第三者が後から同じ結論を追試できるかです。ここで中心になるのが、ブロック構造、ハッシュ連結、Merkle Treeです。結論を先に言うと、ブロックチェーンは「取引の羅列」ではなく、順序共有の結果を検証可能な記録として固定するための構造です。[一次:S-CH06-001][一次:S-CH05-001]

## 1. ブロック構造

最初に日常導入を置きます。領収書を机上に時系列で置くだけだと、監査するときに「どこまでが同じ検査単位か」が曖昧になります。月ごとに束ね、束ごとに表紙へ要約を付ければ、確認の境界が明確になります。ブロック構造は、この「束」と「表紙」の組み合わせに相当します。[一次:S-CH06-001]

ブロックは通常、ヘッダと本文に分かれます。ヘッダには前ブロック参照、タイムスタンプ、難易度関連情報、Merkle rootなどが入り、本文には取引集合が入ります。要点は、毎回全取引を読み直さなくても、ヘッダ情報から整合性チェックを始められることです。これにより、検証コストと検証順序が安定します。[一次:S-CH06-001]

素朴案として「取引を1件ずつ逐次ログへ書けば十分」と考えると、検証単位が固定できません。どこで切って比較するかが曖昧だと、ノード実装ごとに再検証範囲がずれ、同じ履歴に対する検証時間も大きくぶれます。順序共有では速度そのものより、同じ手順で同じ結論へ到達できることが重要です。[一次:S-CH06-001]

破綻例1は、単位境界なしの長大ログで、途中検証が実装依存になるケースです。破綻例2は、境界定義が曖昧で、ノードAは1000件単位、ノードBは時間単位で束ねるケースです。どちらも比較可能性を壊します。比較可能性が壊れると、収束規則の前段で論争が発生し、合意手順が遅延します。（要検証）

ここで橋渡しを明示します。ブロック構造に求められるのは、第一に検証単位の固定、第二に要約情報の固定、第三に後続単位との接続可能性です。この三点が揃うことで、次節のハッシュ連結が「改ざん検知」として意味を持ちます。[一次:S-CH06-001]

## 2. ハッシュ連結

ハッシュ連結は、各ブロックが前ブロックの要約値（ハッシュ）をヘッダに持つ仕組みです。過去ブロックの内容を変えると要約値が変わるため、後続ブロックの参照が不一致になります。つまり改ざんは「隠れて起こる」のではなく「参照不整合として露出する」ようになります。[一次:S-CH06-001]

日常導入として、契約書の各ページ末尾に前ページ要約を入れる運用を考えます。途中ページを差し替えると、次ページ以降の要約が一斉に不整合を起こします。ハッシュ連結はこの性質を計算機で再現したものです。ここで重要なのは、差し替え不能を魔法で保証するのではなく、差し替えを可視化しコスト化する前提を作ることです。[一次:S-CH06-001]

素朴案として「最新ブロックだけ整合していればよい」と考えると、履歴の説明責任を失います。中央裁定者がいない環境では、現在状態だけでなく、そこに至る順序の正当性を追える必要があります。履歴連鎖が切れると、現在状態の信頼根拠も弱くなります。[一次:S-CH06-001][一次:S-INTRO-001]

破綻例1は、過去ブロックの取引を改ざんしても後続参照を更新しないケースで、即座に不一致が検出されます。破綻例2は、過去改ざんに合わせて後続参照も再計算するケースで、再計算負荷が連鎖します。後者を実効的に重くするのが第7章のPoWと難易度設計です。[一次:S-CH06-001][一次:S-CH07-001]

橋渡しとして、役割分担を固定します。ハッシュ連結は「改ざん検知の骨格」を担い、PoWは「改ざん再計算コストの増幅」を担います。両者を混同すると、どこで安全余裕が削れたかを診断できません。設計比較では必ず別軸で評価する必要があります。[一次:S-CH06-001][一次:S-CH07-001]

## 3. Merkle Tree

Merkle Treeの役割は、ブロック内の取引包含を効率よく検証できるようにすることです。すべての取引を毎回全件走査しなくても、対象取引に対応する要約経路を辿れば包含の真偽を確認できます。これにより、軽量検証や部分監査でも整合性確認が可能になります。[一次:S-CH06-001]

ここで素朴案として「全部読めばよい」を採ると、理論的には正しくても運用コストが急増します。特に、頻繁な照会や多数利用者への証明提供が必要な場面では、全件走査はレイテンシと計算負荷の両面で非現実的です。Merkle構造は、検証の完全性を保ちながら必要データ量を絞る設計です。[一次:S-CH06-001]

破綻例1は、要約木がないため単一取引照会でも全件読み込みが必要になるケースです。破綻例2は、木の構築順序やペアリング規則が実装差で揺れ、同じ取引集合でもrootが一致しないケースです。後者は仕様準拠の手順固定がないと起きます。したがって「高速化」より先に「手順固定」を優先する必要があります。[一次:S-CH06-001]

日常導入で言い換えると、Merkle Treeは「分厚い台帳の総目次」です。ある項目が台帳に載っているかを確かめるのに、毎回全ページをめくる代わりに、目次経路だけを辿る。目次作成規則が統一されていれば、誰が確認しても同じ位置に到達できます。

橋渡しを明示します。Merkle Treeは順序そのものを決めません。順序で確定した取引集合を、検証しやすく提示する仕組みです。順序決定の章（第7〜第8章）と、検証効率の章（本節）を分けて理解すると、方式比較で論点が混ざりません。[一次:S-CH06-001][一次:S-CH08-001]

## 4. 履歴固定

ここまでを統合すると、本章が担うのは「順序共有の結果を記録として固定すること」です。ブロック構造が検証単位を作り、ハッシュ連結が連鎖整合を作り、Merkle Treeが部分検証を可能にします。三者が揃うことで、履歴は第三者が追試できる公開記録になります。[一次:S-CH06-001]

ここで誤解を避けます。履歴固定は「一瞬で絶対不変」になることを意味しません。実運用では分岐と再編成があり、確定性は時間と閾値で運用されます。履歴固定は、その運用を追跡可能にする土台です。最終確定の扱いは第8章で詳細化します。[一次:S-CH08-001][要検証:RB-003]

破綻例として、履歴固定が弱い設計を考えます。例1は、要約連結がなく、過去編集の検知が困難なケースです。例2は、部分検証手段がなく、利用者が常に全履歴同期を強いられるケースです。前者は改ざん検知性を失い、後者は参加障壁を上げ、ネットワークの健全性を長期的に下げます。（要検証）

この破綻から導く要件は三点です。要件1は改ざん検知可能性、要件2は追試可能性、要件3は検証コストの現実性です。要件1だけ満たして要件3を無視すると、理論上安全でも実務で維持できません。要件2だけ満たして要件1を弱めると、説明はできても防御余裕が不足します。三点の同時達成が必要です。[一次:S-CH06-001]

第7章への接続を明示します。次章は、ここで作った「検知できる履歴」に、PoWと難易度調整で「改ざんしにくさ」を重ねます。本章が記録の骨格を作り、第7章がその骨格に攻撃コストを与える関係です。[一次:S-CH07-001]

最後に結論を固定します。ブロックとチェーンの本質は、データを並べることではなく、順序共有の結果を公開・追試・比較できる記録へ変換することです。この変換があるからこそ、中央裁定者なしでも履歴の正当性を共有できます。[一次:S-CH06-001][一次:S-INTRO-001]

### 章内補足: 履歴固定を監査可能性まで拡張する

本章の議論を実務で使うには、「追試可能」という言葉を具体的な監査手順へ落とす必要があります。たとえば監査担当が特定取引の存在と順序位置を確認するとき、どのデータ（ブロックヘッダ、Merkle経路、前ブロック参照）をどの順序で検証すれば結論に到達できるかを明文化しておく必要があります。手順が明文化されていれば、担当者が変わっても同じ証拠から同じ判断に到達できます。（要検証）

監査手順を最小化すると、次の四段になります。第一段は対象ブロックヘッダの整合確認です。第二段は前ブロック参照を辿って連鎖整合を確認します。第三段は対象取引のMerkle経路を検証し、当該ブロックへの包含を確認します。第四段は該当取引の前後関係をブロック高と連鎖位置で確認します。ここで重要なのは、データの量より検証順序の固定です。[一次:S-CH06-001]

また、履歴固定の議論では「どこまでを同一事実として扱うか」を先に決める必要があります。ある運用はブロック受信時点を事実とし、別運用は一定深さ到達時点を事実とするかもしれません。どちらもルールとしては成立し得ますが、混在すると利用者説明が割れます。したがって技術仕様の上に、運用定義としての「事実確定点」を重ねる必要があります。（要検証）

ここで典型的な破綻を二つ挙げます。破綻1は、ヘッダ整合だけ確認して取引包含を確認しないケースです。この場合、連鎖は正しく見えても対象取引の存在証明になりません。破綻2は、取引包含だけ確認して前後関係を見ないケースです。この場合、存在は確認できても順序共有の主張にはなりません。順序と存在を同時に確認してはじめて本書の中心命題に合致します。[一次:S-CH06-001][一次:S-INTRO-001]

さらに、可用性観点の補足も必要です。全ノードが常に全履歴を即時検証できるとは限りません。帯域、保存容量、復元時間の制約があるため、軽量検証と完全検証の役割分担を設計段階で決める必要があります。役割分担がないと、「軽量ノードに何を期待するか」が曖昧になり、障害時に責任が宙に浮きます。（要検証）

この補足を踏まえた実務チェックを置きます。1) ブロック単位の検証境界が文書化されているか。2) 連鎖整合と取引包含の両方を確認しているか。3) 順序主張に必要な前後関係証拠を保持しているか。4) 完全検証と軽量検証の責任分担が定義されているか。5) 第7章のコスト設計と接続できる監査ログを持っているか。これらが揃えば、履歴固定は概念説明から監査実務へ進みます。[一次:S-CH06-001][一次:S-CH07-001]

最後に、本章補足の結論を明示します。ブロックとチェーンの価値は、データ圧縮や表示効率ではなく、第三者が追試できる形で順序と存在を同時に証明できることです。追試可能性を運用手順まで落とし込めるかどうかが、設計理解と実務運用の分岐点になります。[一次:S-CH06-001][一次:S-OUTRO-001]

### 章内補足2: 証拠としての履歴をどう残すか

履歴固定を「保存」ではなく「証拠化」として扱うと、本章の意義が明確になります。保存はデータを残す行為ですが、証拠化は第三者が検証可能な形で残す行為です。証拠化には、データ本体だけでなく検証手順、時点情報、参照関係が必要です。ここまで揃って初めて、後から同じ結論を再現できます。[一次:S-CH06-001]

実務上は、障害対応中に「とにかく復旧」を優先し、検証証跡が抜け落ちることがあります。短期復旧は重要ですが、証跡を落とすと再発防止で同じ論点を繰り返します。したがって、復旧手順の中に最小証跡採取を必須項目として組み込む必要があります。（要検証）

本章を読んだ後の確認項目は次です。1) ブロック境界が明示されているか。2) 連鎖参照で改ざん検知ができるか。3) Merkle経路で包含確認ができるか。4) その証拠を他者へ提示できるか。四つが揃えば、履歴固定は「あると言い張る」状態から「示せる」状態へ進みます。[一次:S-CH06-001]

この「示せる状態」が次章のPoW評価に直結します。なぜなら、どれだけコストを課しても、何を守っているかが証拠化されていなければ安全性議論が空中戦になるからです。第6章は第7章の前提として、守る対象の形を固定する章だと理解してください。[一次:S-CH07-001]

### 章内補足3: 監査再現性の最終確認

本章の実務的な到達点は、任意の取引について「存在したか」「どの順序で含まれたか」を第三者が再現できることです。これができなければ、履歴は保存されていても証拠にはなりません。保存と証拠化を分ける視点を、常に維持する必要があります。[一次:S-CH06-001]

具体的には、監査担当が別環境で同じ検証を実行し、同じ結論へ到達できることを確認します。到達できない場合は、データ欠落、手順欠落、定義欠落のどれかです。欠落種類を切り分けて補うことで、履歴固定は技術説明から運用保証へ進みます。（要検証）

追補として、履歴固定を評価するときは「保存できるか」ではなく「第三者が同じ結論へ到達できるか」を基準にしてください。検証手順の共有まで含めてはじめて、記録は証拠として機能します。[一次:S-CH06-001]

追補として、履歴固定を運用評価する際は、障害時にどこまで遡って証拠を復元できるかを必ず確認してください。平常時に見える整合だけでは不十分で、復旧局面で同じ証拠列を再構成できるかが本当の評価点です。再構成できる設計は、障害後の説明と改善を早めます。再構成できない設計は、毎回ゼロベース調査となり、運用品質が累積的に低下します。[一次:S-CH06-001]

本章の締めとして、履歴固定の品質は「監査担当が別日に同じ証拠で同じ結論へ到達できるか」で測るべきだと強調します。到達できる設計は、障害後の意思決定を速くし、責任分界を明確にします。到達できない設計は、毎回の判断が属人的になり、同じ障害を繰り返します。ブロック構造、ハッシュ連結、Merkle経路は、この再現可能性を成立させるための三点セットです。[一次:S-CH06-001]

最終補足として、履歴固定を評価するときは、証拠の完全性と説明の一貫性を同時に点検してください。両方が揃う設計だけが、順序共有の主張を長期に維持できます。[一次:S-CH06-001]

要するに、履歴固定の品質は「後から追えるか」で決まります。追える設計は説明を短くでき、追えない設計は説明を長くしても納得を得にくくなります。[一次:S-CH06-001]

ここで終端を統合します。履歴固定の品質は「後から追えるか」で決まり、追える設計は障害後の説明と改善を速くします。追えない設計は、同じ障害を毎回ゼロから調査する状態を生みます。したがって本章の実務的最小基準は、ブロック境界、連鎖参照、包含経路、順序証拠を一体で再現できることです。これを満たしてはじめて、履歴固定は保存から証拠化へ進みます。[一次:S-CH06-001]

補足として、検証手順の共有を監査手順に組み込むことを必須要件にしてください。[一次:S-CH06-001]

この点を章内で明示した状態を維持してください。[一次:S-CH06-001]

。 

補足として、履歴固定を評価するときは「証拠の寿命」を確認してください。平常時に検証できても、障害後に必要証跡が失われる設計では長期運用で説明責任を果たせません。どの証跡をどの期間保持し、誰が再検証可能かを先に定義しておくと、復旧後の原因分析速度が大きく変わります。ブロック連結とMerkle構造は短期検証だけでなく、時間が経った後の再説明を支えるためにあります。第6章をこの視点で読むと、保存と証拠化の差がより明確になります。（要検証）
